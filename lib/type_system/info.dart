//1) Назвал различия между статической и динамической, строгой и нестрогой типизацией языков программирования.
//2) Назвал типизацию языка dart и доказал это примерами кода.
//3) Привел доводы, почему в dart нет “простых” типов.
//4) Привел доводы, почему Object - это базовый класс всех типов в dart, и зачем он нужен.
//5) Назвал разницу между var/final/const и когда стоит использовать тот или иной модификатор.
//6) Сказал +/- late модификатора и когда его стоит использовать.
//7) Пояснил за dynamic концепцию в языке.
//8) Когда его стоит/не стоит использовать.
//9) Можно ли обойтись без него?
//10) Пояснить принцип infer type и как он работает.
//11) Когда его использование может привести к неожиданным багам?

//1)  Статическая/динамическая типизация - язык определяет тип переменных при компиляции/во время выполнени
//  Строгая/нестрогая типизация - язык требует/не требует явно указывать тип переменных
//
//2) Dart имеет и строгую и динамическую типизацию
//
//3-4)  Все ненулевые типы наследуются от Object, чтобы обсеспечить единообразие и универсальность языка.
//  Они получают возможность использовать методы Object, такие как hash, toString.
//  Так-же это позволяет более точно контролировать типы данных.
//  Возможно реализовать полиморфизм, так как все типы наследуются от Object
//  Обработка исключений так же реализована в базовом классе
//  Возможность программы анализировать и менять свое поведение,
//  благодаря instanceOf, runtimeType, реализованных в Object
//
//5)  var - изменяемая, тип определяется статическим анализатором
//    final - неизменяемая, тип определяется статическим анализатором, з
//      начение присваевается в рантайме
//    const - неизменяемая, тип определяется статическим анализатором,
//      значение присваевается во время компиляции, значение кешируется и сокращает использование памяти
//
//6)  late позволяет отложить инициализацию переменной до ее первого ипользования
//  Плюсы:
//    удобная инициализация, уменьшение вычислений
//  Минусы:
//    возможность возникновения ошибок, усложнение кода, если есть связи между late переменными
//
//7-9)  Тип dynamic переменных определяется и меняется в рантайме,
//  он не проверяется статическим анализатором - отсюда плюсы и минусы.
//  Без dynamic можно обойтись, так как все типы являются Object,
//  и мы можем использовать приведение Object к подтипу, но это много когда
//
//10)  Определяет тип полей методов и локальных переменных на основе статического анализа
//  если не хватает информации, использует dynamic
